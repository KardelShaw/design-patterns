#享元(Flyweight)模式

##一. 概述

在面向对象系统的设计何实现中，创建对象是最为常见的操作。

这里面就有一个问题：如果一个应用程序使用了太多的对象，就会造成很大的存储开销。特别是对于大量轻量级（细粒度）的对象，比如在文档编辑器的设计过程中，我们如果没有为字母创建一个对象的话，系统可能会因为大量的对象而造成存储开销的浪费。

例如一个字母“a”在文档中出现了100000次，而实际上我们可以让这一万个字母“a”共享一个对象，当然因为在不同的位置可能字母“a”有不同的显示效果（例如字体和大小等设置不同），在这种情况我们可以为将对象的状态分为“外部状态”和“内部状态”，将可以被共享（不会变化）的状态作为内部状态存储在对象中，而外部对象（例如上面提到的字体、大小等）我们可以在适当的时候将外部对象最为参数传递给对象（例如在显示的时候，将字体、大小等信息传递给对象）。

##二. 享元模式

定义：运用共享技术有效地支持大量细粒度的对象。
结构图如下：
![结构图](./uml.png)

###享元模式中主要角色

抽象享元(Flyweight)角色：此角色是所有的具体享元类的超类，为这些类规定出需要实现的公共接口。那些需要外蕴状态的操作可以通过调用商业以参数形式传入

具体享元(ConcreteFlyweight)角色：实现Flyweight接口，并为内部状态（如果有的话）拉回存储空间。ConcreteFlyweight对象必须是可共享的。它所存储的状态必须是内部的

不共享的具体享元（UnsharedConcreteFlyweight）角色：并非所有的Flyweight子类都需要被共享。Flyweigth使共享成为可能，但它并不强制共享。

享元工厂(FlyweightFactory)角色：负责创建和管理享元角色。本角色必须保证享元对象可能被系统适当地共享

客户端(Client)角色：本角色需要维护一个对所有享元对象的引用。本角色需要自行存储所有享元对象的外部状态

Flyweight：所有具体享元类的父类，或接口

ConcreteFlyweight：具体享元类，实现具体的操作

UnshareConcreteFlyweight：不需要共享的子类

FlyweightFactory：合理的创建并管理享元类

##三. 说明

1. 享元工厂类是重点，因为它创建并管理享元对象，对没有的对象它会创建，对已有的对象它会提供一个已创建的实例。
2. 可以想像有一个对象池，里面都是一些享元类，享元工厂的作用就是从对象池里取对象。
3. 它的目的是大幅度地减少需要实例化的类的数量。
4. Flyweight模式使得系统更加复杂
5. Flyweigth模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长

##享元模式适用场景
当以下情况都成立时使用Flyweight模式：

1. 一个应用程序使用了大量的对象
2. 完全由于使用大量的对象，造成很大的存储开销
3. 对象的大多数状态都可变为外部状态
4. 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象
5. 应用程序不依赖于对象标识。

##享元模式与其它模式
单例模式(Singleton)：客户端要引用享元对象，是通过工厂对象创建或者获得的，客户端每次引用一个享元对象，都是可以通过同一个工厂对象来引用所需要的享元对象。因此，可以将享元工厂设计成单例模式，这样就可以保证客户端只引用一个工厂实例。因为所有的享元对象都是由一个工厂对象统一管理的，所以在客户端没有必要引用多个工厂对象。不管是单纯享元模式还是复合享元模式中的享元工厂角色，都可以设计成为单例模式，对于结果是不会有任何影响的。

Composite模式：复合享元模式实际上是单纯享元模式与合成模式的组合。单纯享元对象可以作为树叶对象来讲，是可以共享的，而复合享元对象可以作为树枝对象，因此在复合享元角色中可以添加聚集管理方法。