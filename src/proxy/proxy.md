#Proxy模式

##作用：
　　
Provide a surrogate or placeholder for another object to controlaccess to it.(为其他对象提供一种代理以控制对这个对象的访问)
　　
##UML结构图：
　　
![UML结构图](./uml.png)
　　　　
##抽象基类：
　
Subject：定义了Proxy和RealSubject的公有接口，这样就可以在任何需要使用到RealSubject的地方都使用Proxy.
　　
##解析：
　　
Proxy其实是基于这样一种时常使用到的技术-某个对象直到它真正被使用到的时候才被初始化，在没有使用到的时候就暂时用Proxy作一个占位符。这个模式实现的要点就是Proxy和RealSubject都继承自Subject，这样保证了两个的接口都是一致的。

##代理模式一般涉及到的角色有：
 
* 抽象角色：声明真实对象和代理对象的共同接口； 

* 代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。 

* 真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。

##代理模式使用原因和应用方面

* 授权机制 不同级别的用户对同一对象拥有不同的访问权利,如Jive论坛系统中,就使用Proxy进行授权机制控制,访问论坛有两种人:注册用户和游客(未注册用户),Jive中就通过类似ForumProxy这样的代理来控制这两种用户对论坛的访问权限.

* 某个客户端不能直接操作到某个对象,但又必须和那个对象有所互动.

	举例两个具体情况: 
    
    如果那个对象是一个是很大的图片,需要花费很长时间才能显示出来,那么当这个图片包含在文档中时,使用编辑器或浏览器打开这个文档,打开文档必须很迅速,不能等待大图片处理完成,这时需要做个图片Proxy来代替真正的图片.
     
     如果那个对象在Internet的某个远端服务器上,直接操作这个对象因为网络速度原因可能比较慢,那我们可以先用Proxy来代替那个对象.
     
     总之原则是,对于开销很大的对象,只有在使用它时才创建,这个原则可以为我们节省很多宝贵的Java内存. 所以,有些人认为Java耗费资源内存,我以为这和程序编制思路也有一定的关系.

* 现实中，Proxy应用范围很广,现在流行的分布计算方式RMI和Corba等都是Proxy模式的应用
* 现实世界中，秘书就相当于一个代理，老板开会，那么通知员工开会时间、布置会场、会后整理会场等等开会相关工作就可以交给秘书做，老板就只需要开会就行了，不需要亲自做那些事。同理，在我们程序设计中也可使用代理模式来将由一系列无关逻辑组合在一起的代码进行解耦合，比如业务代码中的日志代码就可以在代理中进行。Spring的AOP就是典型的动态代理应用。


##代理模式的应用形式

1. 远程代理(Remote Proxy) -可以隐藏一个对象存在于不同地址空间的事实。也使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。
2. 虚拟代理(Virtual Proxy) – 允许内存开销较大的对象在需要的时候创建。只有我们真正需要这个对象的时候才创建。
3. 写入时复制代理(Copy-On-Write Proxy) – 用来控制对象的复制，方法是延迟对象的复制，直到客户真的需要为止。是虚拟代理的一个变体。
4. 保护代理(Protection (Access)Proxy) – 为不同的客户提供不同级别的目标对象访问权限
5. 缓存代理(Cache Proxy) – 为开销大的运算结果提供暂时存储，它允许多个客户共享结果，以减少计算或网络延迟。
6. 防火墙代理(Firewall Proxy) – 控制网络资源的访问，保护主题免于恶意客户的侵害。
7. 同步代理(SynchronizationProxy) – 在多线程的情况下为主题提供安全的访问。
8. 智能引用代理(Smart ReferenceProxy) - 当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。
9. 复杂隐藏代理(Complexity HidingProxy) – 用来隐藏一个类的复杂集合的复杂度，并进行访问控制。有时候也称为外观代理(Façade Proxy)，这不难理解。复杂隐藏代理和外观模式是不一样的，因为代理控制访问，而外观模式是不一样的，因为代理控制访问，而外观模式只提供另一组接口。